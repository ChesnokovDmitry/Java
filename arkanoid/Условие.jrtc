У нас будут кубики, шарик и летающая "подставка", которая не дает шарику упасть.

Нам понадобятся классы:
а) Arkanoid - класс в котором происходят основные действия. Также в нем будет наша точка входа в программу, метод main.
б) Ball - шарик.
в) Brick - "кирпичи", которые мы сбиваем шариком.
г) Stand - летающая подставка.

Требования:
    •Класс Arkanoid должен быть создан в отдельном файле.
    •Класс Ball должен быть создан в отдельном файле.
    •Класс Brick должен быть создан в отдельном файле.
    •Класс Stand должен быть создан в отдельном файле.
    •В классе Arkanoid должен быть создан метод public static void main (String[] args).



------------------------------------------------------------------------------------------------------------------
Главный класс (Arkanoid) хранит информацию о размерах поля, где будут происходить все действия:
а) добавь в класс Arkanoid два приватных поля width(ширина) и height(высота) типа int
б) создай для них публичные геттеры и сеттеры

Требования:

    •В классе Arkanoid должно быть создано приватное поле width типа int.
    •В классе Arkanoid должно быть создано приватное поле height типа int.
    •В классе Arkanoid должен быть создан корректный геттер для поля height.
    •В классе Arkanoid должен быть создан корректный геттер для поля width.
    •В классе Arkanoid должен быть создан корректный сеттер для поля height.
    •В классе Arkanoid должен быть создан корректный сеттер для поля width.



------------------------------------------------------------------------------------------------------------------
Конструктор должен принимать два параметра типа int (width и height).

Требования:
    •В классе Arkanoid должен быть создан публичный конструктор с двумя параметрами типа int.
    •Конструктор класса Arkanoid должен корректно устанавливать значения соответствующих полей класса.



------------------------------------------------------------------------------------------------------------------
Класс Arkanoid хранит ссылку на шарик (Ball), "подставку" Stand и список "кирпичей".

Надо:
а) создать в классе Arkanoid два private поля: ball типа Ball и stand типа Stand
б) добавить private поле bricks типа List<Brick>
в) добавь для них публичные геттеры и сеттеры

Требования:
    •В классе Arkanoid должно быть создано приватное поле ball типа Ball.
    •В классе Arkanoid должно быть создано приватное поле stand типа Stand.
    •В классе Arkanoid должно быть создано приватное поле bricks типа List<Brick>.
    •В классе Arkanoid должен быть создан корректный геттер для поля ball.
    •В классе Arkanoid должен быть создан корректный геттер для поля stand.
    •В классе Arkanoid должен быть создан корректный геттер для поля bricks.
    •В классе Arkanoid должен быть создан корректный сеттер для поля ball.
    •В классе Arkanoid должен быть создан корректный сеттер для поля stand.
    •В классе Arkanoid должен быть создан корректный сеттер для поля bricks.



------------------------------------------------------------------------------------------------------------------
Классу Arkanoid нужен метод run(), в котором будет описана основная логика программы.
Еще нужен метод move() - который будет двигать на один шаг все объекты требующие движения.
Создай методы run() и move().
Еще нам понадобится НЕ приватная статическая переменная game типа Arkanoid, которая будет хранить ссылку на созданный экземпляр класса Arkanoid:
static Arkanoid game;

Требования:
    •В классе Arkanoid должен быть создан метод void run() без параметров.
    •В классе Arkanoid должен быть создан метод void move() без параметров.
    •Метод run должен быть доступен извне класса Arkanoid.
    •Метод move должен быть доступен извне класса Arkanoid.
    •В классе Arkanoid должно быть создано не приватное статическое поле game типа Arkanoid.



------------------------------------------------------------------------------------------------------------------
У нас будут "кирпичи", "шарик" и "подставка" и у них будет много общего.
Они будут перемещаться по полю и отрисовываться.
Значит у них у всех будут координаты и размер.
А еще методы move() - для перемещения и draw() для отрисовки.
Введем один базовый класс для всех объектов.
Создай класс BaseObject и добавь его родителем к классам Ball, Stand, Brick.
Еще нам понадобится класс Canvas.
Он будет ответственным за "отрисовку" объектов.
С помощью его они будут отрисовывать себя.

Требования:
    •Публичный класс BaseObject должен быть создан в отдельном файле.
    •Класс Canvas должен быть создан в отдельном файле.
    •Класс Ball должен быть потомком класса BaseObject.
    •Класс Brick должен быть потомком класса BaseObject.
    •Класс Stand должен быть потомком класса BaseObject.



------------------------------------------------------------------------------------------------------------------
Перейдем к классу BaseObject.
Для простоты будем считать что все объекты у нас будут круглыми (отрисовывать их мы будем фигурными).
При расчетах из взаимодействия исходить из того, что они круглые.
Координаты объектов и радиус будут вещественными числами.
Это придаст плавность движениям и точность всем вычислениям.
А при отрисовке мы будем их округлять.

Итак:
а) Добавь в класс BaseObject приватные поля x (double), y (double), radius (double).
б) Добавь геттеры и сеттеры.
в) Добавь конструктор BaseObject(double x, double y, double radius).
г) Пройдись по всем классам-наследникам и поправь у них конструкторы.

Требования:
    •В классе BaseObject должно быть создано приватное поле x типа double.
    •В классе BaseObject должно быть создано приватное поле y типа double.
    •В классе BaseObject должно быть создано приватное поле radius типа double.
    •В классе BaseObject должен быть создан корректно работающий конструктор с тремя параметрами типа double (x, y, radius).
    •В классе Ball должен быть создан корректно работающий конструктор с тремя параметрами типа double (x, y, radius).
    •В классе Brick должен быть создан корректно работающий конструктор с тремя параметрами типа double (x, y, radius).
    •В классе Stand должен быть создан корректно работающий конструктор с тремя параметрами типа double (x, y, radius).
    •В классе BaseObject должен быть создан публичный геттер для поля x.
    •В классе BaseObject должен быть создан публичный геттер для поля y.
    •В классе BaseObject должен быть создан публичный геттер для поля radius.
    •В классе BaseObject должен быть создан публичный сеттер для поля x.
    •В классе BaseObject должен быть создан публичный сеттер для поля y.
    •В классе BaseObject должен быть создан публичный сеттер для поля radius.



------------------------------------------------------------------------------------------------------------------
Классу BaseObject нужны еще методы.
Пока это будут пустые методы draw(Canvas canvas) и move().
Классы-наследники должны будут переопределить их у себя и реализовать необходимую функциональность (пока можешь оставить их пустыми, просто чтобы код компилировался).
Объяви эти методы, но сделай их абстрактными.
Также сделай абстрактным сам класс BaseObject.
Еще нам нужно будет определять попал ли шарик в кирпич или в подставку.
Это будем делать так:
В этом же классе, создадим специальный метод: boolean isIntersec(BaseObject o)
Он будет определять - "пересеклись" объекты или нет. Если пересеклись - возвращать true, если нет - false.
Т.к. объекты мы условно считаем кругами, то формула взаимодействия:
если центр круга одного объекта попал в круг другого, то будем считать, что они столкнулись.
Или еще проще:
дистанция_между_объектами <= max (радиус_первого_объекта, радиус_второго_объекта)

Требования:
    •Класс BaseObject должен быть абстрактным.
    •В классе BaseObject должен быть объявлен абстрактный метод draw() c одним параметром типа Canvas.
    •В классе BaseObject должен быть объявлен абстрактный метод move() без параметров.
    •В классе BaseObject должен быть реализован метод isIntersec() с одним параметром типа BaseObject, возвращающий true в случае, если текущий объект пересекается с анализируемым.



------------------------------------------------------------------------------------------------------------------
Класс Canvas.
Он у нас будет содержать матрицу (двумерный массив), куда мы будем "рисовать".
У матрицы есть ширина и высота.
А еще будем в ней хранить не числа (int), а символы (char).

Надо:
а) Добавить в класс два приватных поля width и height.
б) Добавить в класс приватное поле matrix (char[][]).
в) Добавить конструктор с двумя параметрами типа int (width и height), поле matrix должно быть инициализировано пустым массивом размерностью [height+2][width+2].
г) Добавить геттеры и сеттеры для всех приватных полей класса.

Требования:
    •В классе Canvas должно быть создано приватное поле width типа int.
    •В классе Canvas должно быть создано приватное поле height типа int.
    •В классе Canvas должно быть создано приватное поле matrix типа char[][].
    •В классе Canvas должен быть создан публичный геттер для поля width.
    •В классе Canvas должен быть создан публичный геттер для поля height.
    •В классе Canvas должен быть создан публичный геттер для поля matrix.
    •В классе Canvas должен быть создан публичный сеттер для поля width.
    •В классе Canvas должен быть создан публичный сеттер для поля height.
    •В классе Canvas должен быть создан публичный сеттер для поля matrix.
    •В классе Canvas должен быть создан корректный публичный конструктор с двумя параметрами типа int (width и height).



------------------------------------------------------------------------------------------------------------------
Мы будем рисовать в Canvas (в его матрице).
Поэтому нам понадобятся два метода:
void setPoint(double x, double y, char c)
void drawMatrix(double x, double y, int[][] matrix, char c)
Первый метод - setPoint будет "ставить точку в координатах x,y цветом c".

В методе надо:
а) округлить x и y до целых чисел
б) занести в matrix[y][x] значение с
в) ничего не делать, если x < 0 или y < 0 или y >= matrix.length или x >= matrix[0].length

Второй метод - drawMatrix копирует переданную ему картинку (матрицу) в матрицу Canvas.
И не просто копирует, а начиная с координат x, y

В методе надо:
а) с помощью двух вложенных циклов пройтись по всем ячейкам переданной картинки
б) если значение ячейки элемента [i][j] полученной матрицы не равно 0, то покрасить в матрице объекта Canvas точку (x+j, y+i) в цвет c:
setPoint(x+j, y+i, c)

Требования:
    •В классе Canvas должен быть создан метод void setPoint(double x, double y, char c).
    •В классе Canvas должен быть создан метод void drawMatrix(double x, double y, int[][] matrix, char c).
    •Поведение метода setPoint должно соответствовать условию задачи.
    •Поведение метода drawMatrix должно соответствовать условию задачи.



------------------------------------------------------------------------------------------------------------------
Еще Canvas понадобится два метода.
а) метод clear()
Этот метод будет очищать матрицу, чтобы на ней снова можно было рисовать.
б) метод print()
Этот метод рисует матрицу на экран.

Требования:
    •В классе Canvas должен быть создан метод void clear() без параметров.
    •В классе Canvas должен быть создан метод void print() без параметров.
    •Метод clear должен очищать массив matrix.
    •Метод print должен выводить на экран содержимое массива matrix.



------------------------------------------------------------------------------------------------------------------
Классом Brick.
В конструкторе зададим "радиус" всех кирпичей.
public Brick(double x, double y) {
  super(x, y, 3);
}
В классе Brick есть два переопределенных метода: move() и draw(Canvas canvas).
Метод move() не делает ничего (не содержит кода), т.к. кирпич никуда не двигается.

Требования:
    •Конструктор класса Brick должен принимать два параметра типа double и вызывать конструктор класса родителя с фиксированным третьим параметром (радиусом) равным 3.
    •В классе Brick должен существовать метод move без параметров.
    •В классе Brick должен существовать метод draw с одним параметром типа Сanvas.



------------------------------------------------------------------------------------------------------------------
Класс Ball.
Нам понадобятся приватные поля:
а) speed (скорость шарика) типа double;
б) direction (направление движения в градусах: от 0 до 360) типа double;
в) dx (расстояние по x, которое проходит шарик за один шаг. вычисляется на основе speed и direction) типа double;
г) dy (расстояние по y, которое проходит шарик за один шаг. вычисляется на основе speed и direction) типа double;
д) isFrozen ("истина" если шарик "заморожен" - не двигается) типа boolean.
Добавить геттеры для всех полей этого класса, кроме isFrozen (его мы будем использовать только внутри класса Ball).

Конструктор:
а) параметры - x, y, speed, direction;
б) радиус (для вызова родительского класса) всегда равен 1;
в) не забудь установить isFrozen в true - в начале игры шарик никуда не летит.

Требования:
    •Приватное поле speed типа double должно быть создано в классе Ball.
    •Приватное поле direction типа double должно быть создано в классе Ball.
    •Приватное поле dx типа double должно быть создано в классе Ball.
    •Приватное поле dy типа double должно быть создано в классе Ball.
    •Приватное поле isFrozen типа boolean должно быть создано в классе Ball.
    •В классе Ball должен быть создан публичный конструктор (поведение и параметры описаны в условии).
    •В классе Ball должен существовать корректный публичный геттер для поля speed.
    •В классе Ball должен существовать корректный публичный геттер для поля direction.
    •В классе Ball должен существовать корректный публичный геттер для поля dx.
    •В классе Ball должен существовать корректный публичный геттер для поля dy.



------------------------------------------------------------------------------------------------------------------
Класс Ball:
Во-первых надо реализовать метод move(), унаследованный от BaseObject:
а) x должен увеличиваться на dx каждый ход
б) y должен увеличиваться на dy каждый ход
если шарик "заморожен", то x и y меняться не должны.

Во-вторых надо реализовать метод draw(Canvas canvas):
на объекте canvas необходимо вызвать метод setPoint с параметрами (x, y, 'O')

В-третьих надо реализовать метод start()
Именно его вызов "размораживает" шарик.

P.S. Поля x, y и radius объявлены в классе BaseObject с модификатором доступа private. Измени его на protected, чтобы все потомки класса BaseObject 
имели контроль над своими координатами и размерами, без необходимости пользоваться " чужими" геттерами и сеттерами.

Требования:
    •Метод move() в классе Ball должен увеличивать значение x на dx, если значение поля isFrozen равно false.
    •Метод move() в классе Ball должен увеличивать значение y на dy, если значение поля isFrozen равно false.
    •Метод move() в классе Ball не должен менять значения полей x и y, если значение поля isFrozen равно true.
    •В классе Ball должен быть реализован метод draw(Canvas canvas) в соответствии с условием задачи.
    •В классе Ball должен быть реализован метод start() устанавливающий значение поля isFrozen в false.
    •Модификатор доступа поля x в классе BaseObject должен быть изменен на protected.
    •Модификатор доступа поля y в классе BaseObject должен быть изменен на protected.
    •Модификатор доступа поля radius в классе BaseObject должен быть изменен на protected.



------------------------------------------------------------------------------------------------------------------
Далее нужен метод setDirection, который не только устанавливает значение переменной direction, но и вычисляет новые значения переменных dx и dy.
this.direction = direction;
double angle = Math.toRadians(direction);
dx = Math.cos(angle) * speed;
dy = -Math.sin(angle) * speed.
Шарик может удариться о стенку. При этом он должен от нее отскочить.
Для этого нам понадобится еще один метод:
void checkRebound(int minx, int maxx, int miny, int maxy)

Требования:
    •В классе Ball должен быть создан метод setDirection() c одним параметром типа double (реализацию смотри в условии).
    •В классе Ball должен быть создан метод checkRebound c четырьмя параметрами типа int.



------------------------------------------------------------------------------------------------------------------
Класс Stand.
Ей понадобятся такие приватные поля:
а) speed (скорость шарика) типа double;
б) direction (направление движения по оси x: 1 - вправо, -1 - влево, 0 - начальное значение, стоим на месте) типа double.
Также создай для них геттеры и конструктор:
public Stand(double x, double y) {
super(x, y, 3);
speed = 1;
direction = 0;
}

Требования:
    •В классе Stand должно быть создано приватное поле speed типа double.
    •В классе Stand должно быть создано приватное поле direction типа double.
    •В классе Stand должен быть реализован публичный геттер для поля speed.
    •В классе Stand должен быть реализован публичный геттер для поля direction.
    •В классе Stand должен быть реализован конструктор с двумя параметрами типа double в соответствии с условием задачи



------------------------------------------------------------------------------------------------------------------
Нужны методы:
а) move - см. move в BaseObject
Движение доски осуществляется горизонтально, поэтому мы меняем только координату х.
Подумай, как координата х зависит от направления (direction) и скорости (speed). Реализуй зависимость.
б) draw - см. draw в BaseObject
в) moveLeft() - задает постоянное движение "подставки" влево
г) moveRight() - задает постоянное движение "подставки" вправо

Требования:
    •В классе Stand должен быть реализован метод move увеличивающий координату x на произведение значений полей speed и direction.
    •В классе Stand должен быть реализован метод moveLeft, устанавливающий значение поля direction равным -1.
    •В классе Stand должен быть реализован метод moveRight, устанавливающий значение поля direction равным 1.



------------------------------------------------------------------------------------------------------------------
Класс Arkanoid.
Реализуй методы:
а) move()
В этом методе нужно двигать все движимые объекты (stand, ball).
б) draw(Canvas canvas)
В этом методе надо вызвать метод draw всех существующих объектов, которые его имеют.

Требования:
    •В классе Arkanoid должен быть реализован метод move() без параметров, вызывающий методы move() у шарика и подставки.
    •В классе Arkanoid должен быть реализован метод draw(Canvas canvas), вызывающий методы draw у шарика, подставки и всех кирпичей.



------------------------------------------------------------------------------------------------------------------
В классе Arkanoid создай поле приватное isGameOver типа boolean.
Реализуй метод checkBricksBump.
В этом методе надо проверить - не столкнулся ли шарик с каким-нибудь из "кирпичей".
Для проверки столкновения используй метод isIntersec.
Если шарик все-таки попал в кирпич, то:
а) шарик отлетает в случайном направлении:
double angle = Math.random() * 360;
ball.setDirection(angle);
б) кирпич умирает - надо удалить его из списка всех кирпичей.

Реализуй метод checkStandBump.
В этом методе надо проверить - не ударился ли шарик о подставку.
Для проверки столкновения используй метод isIntersec.
Если шарик все-таки ударился о подставку, то:
шарик отлетает в случайным направлении вверх:
double angle = 90 + 20 * (Math.random() - 0.5);
ball.setDirection(angle);

Реализуй метод checkEndGame.
Если координата y шарика больше чем высота поля игры (height), значит шарик улетел вниз за границу экрана.
В этом случае надо переменную isGameOver установить в true.

Требования:
    •В классе Arkanoid должен быть реализован метод checkBricksBump() в соответствии с условием задачи.
    •В классе Arkanoid должен быть реализован метод checkStandBump() в соответствии с условием задачи.
    •В классе Arkanoid должно быть создано приватное поле isGameOver типа boolean.
    •В классе Arkanoid должен быть реализован метод checkEndGame() в соответствии с условием задачи.
